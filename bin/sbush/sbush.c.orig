#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/defs.h>
<<<<<<< HEAD
#include <sys/env.h>

||||||| merged common ancestors
=======
#include <sys/env.h>
>>>>>>> origin/proj_pempt

#define MAX_INPUT 512
#define TRUE 1
#define FALSE 0

char  str_buf[MAX_INPUT];
char  path_buf[MAX_INPUT];
char* pipes[64];
char* tokens[8];
char* mod_tokens[64];
char  path_var[MAX_INPUT] = "/home/aahangar/workdir/rootfs/bin/";
char  ps1_var[MAX_INPUT] = "sbush>";
char* sargv[] = {"bin/ls", NULL};
char* senvp[] = {"PATH=/home/jvishal/bin:/home/jvishal/.local/bin:/shared/bin:/bin", NULL};


//env start



//env end
int   err;
char* perr;

<<<<<<< HEAD
char weekdayn[7][4] = {
    "Mon",
    "Tue",
	"Wed",
	"Thu",
	"Fri",
	"Sat",
	"Sun"
};

char monthn[13][5] = {
    "Jan",
    "Feb",
	"Mar",
	"Apr",
	"May",
	"Jun",
	"July",
	"Aug",
	"Oct",
	"Sept",
	"Nov",
	"Dec"
};
||||||| merged common ancestors
char* getenv(const char * var_name) {
   if(!strcmp(var_name, "PATH"))
      return path_var;
   else if(!strcmp(var_name, "PS1"))
      return ps1_var;
   else
      return NULL;
}

void setenv(const char * var_name, const char * var_value, int overwrite) {
   int idx=0;
   //TODO: Implement strcpy
   if(!strcmp(var_name, "PATH")){
      while(var_value[idx] != '\0') {
         path_var[idx] = var_value[idx];
         idx++;
      }
      path_var[idx] = '\0';
   }
   else if(!strcmp(var_name, "PS1")){
      while(var_value[idx] != '\0') {
         ps1_var[idx] = var_value[idx];
         idx++;
      }
      ps1_var[idx] = '\0';
   }
}
=======
extern char PWD[MAX_NAME+1];
extern char PS1[MAX_NAME+1];

void memseti(void* dest, int value, int count){
	//puts("memset called\n");
	memset(dest, value, count);
}
//char* getenv(const char * var_name) {
//   if(!strcmp(var_name, "PATH"))
//      return path_var;
//   else if(!strcmp(var_name, "PS1"))
//      return ps1_var;
//   else
//      return NULL;
//}

//void setenv(const char * var_name, const char * var_value, int overwrite) {
//   int idx=0;
//   //TODO: Implement strcpy
//   if(!strcmp(var_name, "PATH")){
//      while(var_value[idx] != '\0') {
//         path_var[idx] = var_value[idx];
//         idx++;
//      }
//      path_var[idx] = '\0';
//   }
//   else if(!strcmp(var_name, "PS1")){
//      while(var_value[idx] != '\0') {
//         ps1_var[idx] = var_value[idx];
//         idx++;
//      }
//      ps1_var[idx] = '\0';
//   }
//}
>>>>>>> origin/proj_pempt


void setprompt() {
    char *temp;
    temp = getenv(ENV_PS1);
    char buff[50];
    if(temp == NULL) {
       printf("%s#sbush>", getcwd(buff, 50));
    }
    else {
<<<<<<< HEAD
       //bprintf("cwd :  %s. %s.\n", getcwd(buff, 50), temp);
       printf("%s#%s",getcwd(buff, 50), temp);
||||||| merged common ancestors
       puts(getenv("PS1"));
=======
       printf("%s#%s",getcwd(buff, 50),PS1);
>>>>>>> origin/proj_pempt
    }
}

<<<<<<< HEAD
||||||| merged common ancestors
int execute(char* cmd, int pos, char * envp[]) {

    int pipe_ids[2];
    static int pipe_prev;

    err = pipe(pipe_ids);

    int idx = 0;
    tokens[idx] = strtok(cmd, " ");
    while (tokens[idx] != NULL) {
        tokens[++idx] = strtok(NULL, " ");
    }

    if (idx == 0) return 0;

    if (!strcmp(tokens[0], "cd")) {
        err = chdir(tokens[1]);
        return 0;
    }
    else if (!strcmp(tokens[0], "export")) {
        setenv(tokens[1], tokens[2], 1);
        return 0;
    }

    int pd, bp, status;
    if(tokens[idx-1][0] == '&') {
        bp = TRUE;
    }
    else {
        bp = FALSE;
    }

    //PATH code
    mod_tokens[0] = path_buf;
    for(int i = 1; i < idx; i++)
        mod_tokens[i] = tokens[i];
    for(int i = idx; i < 64; i++)
        mod_tokens[i] = NULL;

    int idx1 = 0;
    while(path_var[idx1] != '\0'){
        path_buf[idx1] = path_var[idx1];
        idx1++;
    }
    int idx2 = 0;
    while(tokens[0][idx2] != '\0'){
        path_buf[idx1+idx2] = tokens[0][idx2];
        idx2++;
    }
    path_buf[idx1+idx2] = '\0';

    if(tokens[0][0] != '/' && access(path_buf, X_OK) != -2) pd = 1;
    else pd = 0;

    if (pd == 0) {
       int idx2 = 0;
       while(tokens[0][idx2] != '\0'){
           path_buf[idx2] = tokens[0][idx2];
           idx2++;
       }
       path_buf[idx2] = '\0';
    }
    //PATH code

    pid_t pid = fork();
=======
int execute(char* cmd, int pos, char * envp[]) {

    int pipe_ids[2];
    static int pipe_prev;

    err = pipe(pipe_ids);

    int idx = 0;
    tokens[idx] = strtok(cmd, " ");
    while (tokens[idx] != NULL) {
        tokens[++idx] = strtok(NULL, " ");
    }

    if (idx == 0) return 0;

    if (!strcmp(tokens[0], "cd")) {
        err = chdir(tokens[1]);
        return 0;
    }
    else if (!strcmp(tokens[0], "export")) {
        //setenv(tokens[1], tokens[2], 1);
        return 0;
    }

    int pd, bp, status;
    if(tokens[idx-1][0] == '&') {
        bp = TRUE;
    }
    else {
        bp = FALSE;
    }

    //PATH code
    mod_tokens[0] = path_buf;
    for(int i = 1; i < idx; i++)
        mod_tokens[i] = tokens[i];
    for(int i = idx; i < 64; i++)
        mod_tokens[i] = NULL;

    int idx1 = 0;
    while(path_var[idx1] != '\0'){
        path_buf[idx1] = path_var[idx1];
        idx1++;
    }
    int idx2 = 0;
    while(tokens[0][idx2] != '\0'){
        path_buf[idx1+idx2] = tokens[0][idx2];
        idx2++;
    }
    path_buf[idx1+idx2] = '\0';

    if(tokens[0][0] != '/' && access(path_buf, X_OK) != -2) pd = 1;
    else pd = 0;

    if (pd == 0) {
       int idx2 = 0;
       while(tokens[0][idx2] != '\0'){
           path_buf[idx2] = tokens[0][idx2];
           idx2++;
       }
       path_buf[idx2] = '\0';
    }
    //PATH code

    pid_t pid = fork();
>>>>>>> origin/proj_pempt

int main(int argc, char* argv[], char* envp[]) {

    setenv(ENV_PS1, "sbush>");
    setenv(ENV_PATH, "/home/jvishal/bin:/home/jvishal/.local/bin:/shared/bin:/bin:/usr/sbin");
	printf("Users : jvishal, aahangir, user1. Password is root.\n");

	char username[30];
	char password[30];
	printf("\n");
	LOGOUT:while(1){
		printf("username:");
		perr = gets(username);
		printf("password:");
		perr = gets(password);


        //int user_id = 0;
		if(!strcmp("jvishal", username) && !strcmp("root", password))
		{
			printf("Welcome Vishal.\n");
			setenv(ENV_HOME, "/usr/jvishal/");
            //setuid(user_id);
			chdir("/usr/jvishal/");
			break;

		}

        if(!strcmp("aahangir", username) && !strcmp("root", password)){
			puts("Welcome Atif ahangir.\n");
			setenv(ENV_HOME, "/usr/aahangir/");
            //user_id = 1;
            //setuid(user_id);
			chdir("/usr/aahangir/");
			break;
		}

        //With 3 users prompt is messed up. #weird.
        if(!strcmp("user1", username) && !strcmp("root", password)){
            printf("Welcome user1 .\n");
            setenv(ENV_HOME, "/usr/user1/");
            chdir("/usr/user1/");
            break;
        }

        printf("username/password :  %s    ,  %s\n", username, password);

		printf("Incorrect username or password.\nTry again.\n");
        printf("Users : jvishal, aahangir, user1. Password is root.\n");


	}


	struct tm tm_time;
	gettime(&tm_time);
	//printf("%d\n", tm_time.tm_wday);
	printf("%s, %s %d  %d :%d :%d,  UTC %d   \n",weekdayn[tm_time.tm_wday-1],monthn[tm_time.tm_mon-1],tm_time.tm_mday,tm_time.tm_hour,tm_time.tm_min,tm_time.tm_sec, tm_time.tm_year);

    char* paths = (char*)malloc(sizeof(char)*200);
    char* cmd  = (char*)malloc(sizeof(char)*100);
    puts("---Welcome to SBUSH shell---\n");

<<<<<<< HEAD
    strcpy(paths, getenv(ENV_PATH));
    //printf("env found :  %s         \n\n", paths);
||||||| merged common ancestors
   return 0;
}

int main(int argc, char* argv[], char* envp[]) {

    puts("---Welcome to SBUSH shell---");
=======
   return 0;
}

int main(int argc, char* argv[], char* envp[]) {

	setenv(ENV_PS1, "sbush>");

    puts("---Welcome to SBUSH shell---\n");
>>>>>>> origin/proj_pempt
    if(argc == 1) {
        while (TRUE) {

            setprompt();

            perr = gets(str_buf);
<<<<<<< HEAD
            //printf("cmd  :  %s \n", str_buf);
            if(strlen(str_buf)==0){
            		continue;
            }else if(!strcmp("logout", str_buf)){
				printf("Logged out\n");
				goto LOGOUT;
			}
            int idx = 0;
			tokens[idx] = strtok(str_buf, " ");
			while (tokens[idx] != NULL) {
				////printf("%s\n",tokens[idx]);
				++idx;
				tokens[idx] = strtok(NULL, " ");
			}
            pid_t pid = fork();
            int status;

            char *curr_path;
            memset(paths, '\0', sizeof(paths));
            strcpy(paths, getenv(ENV_PATH));
            //printf("path : %s\n", paths);
            curr_path = strtok(paths, ":");

            int flag = 0;
            int fd;

            while(curr_path != NULL){
                curr_path = strtok(NULL, ":");
                memset(cmd, '\0', 100);
                strconcat(cmd, curr_path+1);
                if(strlen(curr_path) != 0){
                    strconcat(cmd, "/");
                    strconcat(cmd, tokens[0]);
                }else{

                    strconcat(cmd, tokens[0]+1);
                }
                fd = open(cmd, O_RDONLY);
                if(fd !=-1){
                    flag = 1;
                    close(fd);
                    break;
                }else{

                }

||||||| merged common ancestors

            //tokens[0] = str_buf;
            //tokens[1] = NULL;

            int idx = 0;
            tokens[idx] = strtok(str_buf, " ");
            while (tokens[idx] != NULL) {
              tokens[++idx] = strtok(NULL, " ");
=======
            if(strlen(str_buf)==0){
            		continue;
>>>>>>> origin/proj_pempt
            }
            int idx = 0;
			tokens[idx] = strtok(str_buf, " ");
			while (tokens[idx] != NULL) {
				////printf("%s\n",tokens[idx]);
				++idx;
				tokens[idx] = strtok(NULL, " ");
			}


            tokens[0] = cmd;
            if(flag == 0){
                memset(cmd, '\0', sizeof(cmd));
                if(tokens[0][0] =='/'){
                    cmd++;
                }

                fd = open(tokens[0], O_RDONLY);
                close(fd);
                if(fd !=-1){
                    tokens[0] = cmd;
                }else{
                    printf("CONTINUE\n");
                    continue;
                    }
            }


            char* senvp[] = {"PATH=/home/jvishal/bin /home/jvishal/.local/bin /shared/bin:", NULL};
            if(pid == 0) {
                int ret = 0;
                //printf("execute : %s  \n",tokens[0]);
                ret = execvpe(tokens[0], tokens, senvp);
                if(ret < 0) {
<<<<<<< HEAD
                    printf("Command not found!!\n");
                    //exit(1);
                    }
||||||| merged common ancestors
                  puts("Command not found!!");
                  exit(1);
                }
=======
                       puts("Command not found!!\n");
											 exit(1);
                }
>>>>>>> origin/proj_pempt
            }
            else {
                //puts("Executing waitpid() in Sbush");
                waitpid(pid, &status);
            }

            //while(1); //Put execve here for now, until pipe is implemented.

            //execute_line(str_buf, envp);
        }
    }
//    else {
//        int fd;
//
//        fd = open(argv[1], O_RDONLY);
//        err = read(fd, str_buf, 18*sizeof(char));
//
//        if (!strcmp(str_buf, "#!rootfs/bin/sbush")) { //check if file is executable.
//
//            int temp;
//            err = read(fd, &temp, 1*sizeof(char));
//
//            err = read(fd, &temp, 1*sizeof(char));
//            while (err != 0) {
//                int cidx = 0;
//
//                while (temp != '\n' && err != 0) {
//                    str_buf[cidx++] = (char) temp;
//                    err = read(fd, &temp, 1*sizeof(char));
//                }
//                str_buf[cidx] = '\0';
//
//                execute_line(str_buf, envp);
//                err = read(fd, &temp, 1*sizeof(char));
//            }
//        }
//        else {
//            puts("File is not a valid sbush shell script!");
//        }
//        close(fd);
//    }

    return 0;
}
